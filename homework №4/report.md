# Отчет

## Задание:
Вариант 16. *Задача о нелюдимых садовниках. Имеется пустой участок земли (двумерный массив) и план сада, разбитого на отдельные квадраты. От 10 до 30 процентов площади сада заняты прудами или камнями. То есть недоступны для ухаживания. Эти квадраты располагаются на плане произвольным образом. Ухаживание за садом выполняют два садовника, которые не хотят встречаться друг другом (то есть, одновременно появляться в одном и том же квадрате). Первый садовник начинает работу с верхнего левого угла сада и перемещается слева направо, сделав ряд, он спускается вниз и идет в обратном направлении, пропуская обработанные участки. Второй садовник начинает работу с нижнего правого угла сада и перемещается снизу вверх, сделав ряд, он перемещается влево и также идет в обратную сторону. Если садовник видит, что участок сада уже обработан другим садовником или является необрабатываемым, он идет дальше. Если по пути какой-то участок занят другим садовником, то садовник ожидает когда участок освободится, чтобы пройти дальше. Садовники должны работать одновременно со скоростями, определяемыми как параметры задачи. Прохождение через любой квадрат занимает некоторое время, которое задается константой, меньшей чем времена обработки и принимается за единицу времени. 
**Создать многопоточное приложение, моделирующее работу садовников. При решении задачи использовать мьютексы.** 

## Код на языке С++:
[program.cpp](program/main.cpp) - код  программы.

## (!) Особенности цвета
В программе осуществлен цветной вывод поля (Красный "F" - первый садовник, Зеленый "S" - второй садовник, Черный "+" - препятствие). Локально цвет выводится, но если у Вас по какой-то причине что-то не работает, пожалуйста, удалите define на самой первой строке [program.cpp](program/main.cpp).  Спасибо!

## Входные данные:
Пользователь вводит два целых числа - высоту и ширину поля. Далее необходимо ввести задержку работы каждого из рабочих (временя, уходящее на работу в клетке). 
Введенное число не должно быть меньше 10 (константа перехода на следующую клетку).

## Основная логика
Полем выступает двумерный вектор структур  `Square`. Каждая такая клетка хранит в себе состояние (необработанная, обработанная, обработанная первым/вторым игроком).
В начале программы вызывается метода `inputData()`, отвечающий за ввод данных. Препятствия на поле расставляет метода `setObstacles(Field &field, size_t elementsCount)`. 
Для удобства был переопределен вывод `Field` и `Squre` в консоль.

## Логика работы с потоками и мьютексами
1) Инициализация мьютексов 
Происходит во время создания поля, а именно в теле конструктора Square:
```cpp
Square() {  
    pthread_mutex_init(&mutex, nullptr);  
}
```
2) Запуск потоков
Потоки лежат в глобальном массиве и запускаются в методе `startTreads(Field &field)`:
```cpp
void startTreads(Field &field) {  
    for (auto &i : threads) {  
        pthread_create(&i, nullptr, prepareStep, (void *) &field);  
    }
}
```
Откуда два раза вызывается метод `prepareStep(void *args)`
3) Работа потоков
Метода `prepareStep(void *args)` вызвает сравнение текущего потока с первым потоком из массива:
```cpp
if (pthread_equal(threads[0], pthread_self())) {
	// Передвижений первого садовника
} else {
	// Передвижение второго садовника
}
```
Логика такова, что если выполняющийся поток является первый потоком массива, то необходимо реализовать логику перемещения первого садовника, иначе - был вызыван второй садовник.
4) Перемещение садовников
Каждый из садовников ступает на клетку и вызывает `step(Square &square, SquareState newState)`, где `square` - позиция, куда он переходит, а `newState` - потенциальное состояние клетки после обработки.   
Собственно, в методе `step(...)` происходит вся магия: как только садовник "вступает" на ноавую клетку он вызывает блокировку мьютекса клетки. Таким образом, садовник ограничивает вхождение в эту клетку для его друга. 
Если клетка необработана, то ее состояние меняется на обработанность текущего садвого  и запускается "длительная работа" на квадрате в методе `changeSquareState(Square &square, SquareState newState):`
```cpp
if (square.state == unprocessed) {  
    square.state = newState;  
    newState == first ? usleep(firstDelay) : usleep(secondDelay);  
}
```
После успешной работы садовник разблокирует мьютекс (позволяя второму садовому зайти), а сам начинает путь на другую клетку. Длительность пути является константой и занимает 10 миллисекунд.
5) Объединение потоков
Чтобы добиться корректного высвобождения памяти надо дождаться объединения потоков, этим занимается метод `joinTreads()`
6) Чистка
И, наконец, метод  деструктор `~Square()` высвобождает память из-под мьютексов.

### P.S
Сергей Александрович, хочется сказать вам огрмное спасибо за курс!
Ваш настрой и подача превратил занудный ассемблер в самый интересный предмет на курсе. Желаю Вам не сдаваться и дальше нести радость в этот тленный мир программных инженеров! Жду дальнейших встреч на курсе ОСей :)